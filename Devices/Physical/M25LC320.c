/****************************************************************************/
/*                                                                          */
/*  Programmer: Gregory L Montgomery                                        */
/*                                                                          */
/*  Copyright © 2010-2019                                                   */
/*                                                                          */
/*  COPYING: (See the file COPYING.md for the GNU General Public License).  */
/*  this program is free software, and you may redistribute it and/or       */
/*  modify it under the terms of the GNU General Public License as          */
/*  published by the Free Software Foundation                               */
/*                                                                          */
/* This file is part of Gregory L Montgomery's code base collection Project.*/
/*                                                                          */
/*     Gregory L Montgomery's code base collection Project is free software:*/
/*     you can redistribute it and/or modify  it under the terms of the GNU */
/*     General Public License as published by the Free Software Foundation, */
/*     either version 3 of the License, or (at your option)                 */
/*     any later version.                                                   */
/*                                                                          */
/*     Gregory L Montgomery's code base collection Project is distributed   */
/*     in the hope that it will be useful, but WITHOUT ANY WARRANTY;        */
/*     without even the implied warranty of MERCHANTABILITY or FITNESS FOR  */
/*     A PARTICULAR PURPOSE.  See the GNU General Public License for more   */
/*     details.                                                             */
/*                                                                          */
/*     You should have received a copy of the GNU General Public License    */
/*     along with Gregory L Montgomery's code base collection Project.      */
/*     If not, see <https://www.gnu.org/licenses/>.                         */
/*                                                                          */
/****************************************************************************/
#include <xc.h>
#include "defs.h"
#include "System.h"
#include "PinConfig.h"
#include "Spi.h"
#include "Device.h"
#include "M25LC320.h"
#include "Fops.h"

#define DELAY(x) {volatile int DCounter; for(DCounter = 0; DCounter < x; DCounter++){asm("nop"); asm("nop"); asm("nop");}}

#define DISCRIPTION_M25LC320 "MC25LC320 SPI Mem Service"
#define M25LC320Select       CS1 // CS1 is defined in PinConfig.h generated by the
                                //  project configurator.

// Definitions for 25xx256 Instruction Constants
typedef enum
{
   ReadInst =  0b00000011, // Read data from memory array beginning at selected address
   WriteInst = 0b00000010, // Write data to memory array beginning at selected address
   WrDiInst =  0b00000100, // Reset the write enable latch (disable write operations)
   WrEnInst =  0b00000110, // Set the write enable latch (enable write operations)
   RdSrInst =  0b00000101, // Read STATUS register
   WrSrInst =  0b00000001, // Write STATUS register
} LC320_InstructionSet;

static const LC320_InstructionSet READ = ReadInst;
static const LC320_InstructionSet WRITE = WriteInst;
static const LC320_InstructionSet WRDI = WrDiInst;
static const LC320_InstructionSet WREN = WrEnInst;
static const LC320_InstructionSet RDSR = RdSrInst;
static const LC320_InstructionSet WRSR = WrSrInst;

static const unsigned LC320_MEM_SIZE = 32768;
static const unsigned PAGE_SIZE      =    32;

// Public Block Read/Block Write command through Object interface
// Otherwise private functions
static void ByteWriteMem(unsigned Address, byte Data );
static int  ByteReadMem(unsigned Address);
static Boolean BlockWriteMem( unsigned Address, byte *DataPtr, byte Length );
static Boolean BlockReadMem( unsigned Address, byte *DataPtr, byte Length );
static void WIPPolling(void);
static void WriteEnable(void);
static int  ReadStatus(void);
static int  ClearStatus(void);
static void PutChMem(unsigned);
static void PutStrMem(char *);
static void FlushAdrs(void);
static Boolean DataAvailable(void);
static int  GetChMem(void);
static int  IOCTL(unsigned Operation);

// Private Member Objects
static Service * This;
static fops   * SpiDev;
static SpiOps * SpiIO;
static EEPromStatus EE_Status;
static int PreviousAddress;

// Private File Operations Object
static fops M25LC320RomDevice =
{
   .BlockRead = BlockReadMem,
   .BlockWrite = BlockWriteMem,
   .Available = DataAvailable,
   .Flush = FlushAdrs,
   .GetCh = GetChMem,
   .IOCTL = IOCTL,
   .IndexPtr = 0, // No circular buffer used to Index is always 0
   .PutCh = PutChMem,
   .PutStr = PutStrMem
};

/***********************************************************************/
/*                                                                     */
/*     Function: InitM25LC320                                          */
/*                                                                     */
/*        Input: A Pointer to the Register File                        */
/*               A Pointer to the Spi Object which interfaces to the   */
/*               M25LC320                                              */
/*       Output: A Pointer to the file operations which this Object    */
/*               can perform.                                          */
/*                                                                     */
/*     Overview: This function Istantiates and initializes a M25LC320  */
/*               file object.                                          */
/*                                                                     */
/***********************************************************************/
Service * InitM25LC320(fops * anSpiDev)
{
   M25LC320Select = 1; //Deselect Service
   SpiDev = anSpiDev;
   SpiIO = (struct SpiOperations *)SpiDev->Usr;
   // This needs to be put in a central place.
   SpiIO->Enable(False);
   SpiIO->SelectPrimaryPrescale(1);
   SpiIO->SelectSecondPrescale(2);
   SpiIO->Set16BitMode(False); // Must be in byte only mode!
   SpiIO->Enable(True);   
   if((This = NewDevice(SpiDev)) != 0)
   {
      This->Discription = DISCRIPTION_M25LC320;
      This->DeviceClass = FLASH_MEM;
      M25LC320RomDevice.Usr=(void *)SpiDev;
      This->Driver = &M25LC320RomDevice;
   }
   return This;
}

/***********************************************************************/
/*                                                                     */
/*     Function: IO Control                                            */
/*        Input: None                                                  */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: IO Control for Memory                                 */
/*                                                                     */
/***********************************************************************/
static int IOCTL(unsigned Operation)
{
   unsigned Results = 0; // Load default value

   switch(Operation)
   {
      case FP_RESET:
         Results = ClearStatus();
         break;
      case READ_STATUS: // Read Status
         Results = EE_Status.Stat = ReadStatus();         
         break;
      case WRITE_STATUS:
         break;
      case WRITE_ENABLED:
         Results = (EE_Status.Stat & WEL_WRITE_ENABLED);
         break;
      case BUSY:
         Results = (EE_Status.Stat & WIP_WRITE_IN_PROGRESS);
         break;
      case ENABLE_WRITE: // Write Enable
         WriteEnable();
         break;
      case GET_PAGE_SIZE: // Return Page Size
         Results = PAGE_SIZE;
         break;
      case GET_MEM_SIZE:
         Results = LC320_MEM_SIZE;
         break;
      case GET_NBR_OF_PAGES:
         Results = LC320_MEM_SIZE / PAGE_SIZE;
         break;
   }
   return Results;
}

/***********************************************************************/
/*                                                                     */
/*     Function: Is data available to be read (DataAvailable)          */
/*        Input: None                                                  */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This is a predicate to insure that the device is      */
/*               ready to be read.                                     */
/*                                                                     */
/***********************************************************************/
static Boolean DataAvailable(void){return True;}

/***********************************************************************/
/*                                                                     */
/*     Function: Flush/Reset device.                                   */
/*        Input: None                                                  */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This is a predicate to insure that the device is      */
/*               ready to be read.                                     */
/*                                                                     */
/***********************************************************************/
static void FlushAdrs(void)
{
   PreviousAddress = 0;
}

/***********************************************************************/
/*                                                                     */
/*     Function: Read Status                                           */
/*        Input: None                                                  */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This routine reads the Status Register                */
/*                                                                     */
/***********************************************************************/
static int ClearStatus(void)
{
   int Results = 0;

   M25LC320Select = 0; // Select Service
   SpiIO->Write(WRSR);
   SpiIO->Write(0);
   M25LC320Select = 1; // Deselect Service
   DELAY(50);
   return Results;   
}

/***********************************************************************/
/*                                                                     */
/*     Function: Read Status                                           */
/*        Input: None                                                  */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This routine reads the Status Register                */
/*                                                                     */
/***********************************************************************/
static int ReadStatus(void)
{
   int Results;

   M25LC320Select = 0; // Select Service
   SpiIO->Write(RDSR);
   Results = SpiIO->Read();
   M25LC320Select = 1; // Deselect Service
   DELAY(50);
   return Results;
}

/***********************************************************************/
/*                                                                     */
/*     Function: WriteEnable                                           */
/*        Input: None                                                  */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This routine sets the Write Enable Latch              */
/*                                                                     */
/***********************************************************************/
static void WriteEnable(void)
{
   M25LC320Select = 0; //Select Service
   SpiIO->Write(WREN); 
   M25LC320Select = 1; //Deselect Service
   DELAY(50);
}

/***********************************************************************/
/*                                                                     */
/*     Function: PutChMem                                              */
/*        Input: The data to be written into memory                    */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This function writes one byte of data to the next     */
/*               address after the previous address used.              */
/*                                                                     */
/***********************************************************************/
static void PutChMem(unsigned Value)
{
   ByteWriteMem(++PreviousAddress,(byte)XBty(Value));
}

/***********************************************************************/
/*                                                                     */
/*     Function: Put String into Memory (PutStrMem)                    */
/*        Input: A pointer to a character string                       */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This function writes a string to the 25x256 memory    */
/*               starting at the next address after the previous       */
/*               address used.                                         */
/*                                                                     */
/***********************************************************************/
static void PutStrMem(char * Msg)
{
   if (Msg != 0)
      while (*Msg++)
         ByteWriteMem(++PreviousAddress, (byte) * Msg);
}

/***********************************************************************/
/*                                                                     */
/*     Function: GetChMem                                              */
/*        Input: None                                                  */
/*       Output: The data which was read from memory                   */
/*                                                                     */
/*     Overview: This function reads one byte of data to the next      */
/*               address after the previous address used.              */
/*                                                                     */
/***********************************************************************/
static int GetChMem(void)
{
   return ByteReadMem(++PreviousAddress);
}

/***********************************************************************/
/*                                                                     */
/*     Function: Byte Write Mem                                        */
/*        Input: The address of where in the 25x256 to write the byte  */
/*               to.                                                   */
/*               The byte of Data which is to be written.              */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: Write one byte of data to the 25x256 memory device.   */
/*                                                                     */
/***********************************************************************/
void ByteWriteMem(unsigned Address, byte Data)
{
   M25LC320Select = 0; // Select Service
   SpiIO->Write(WRITE);
   SpiIO->Write(XBty(Address >> 8) );
   SpiIO->Write(XBty(Address) );
   SpiIO->Write(Data);
   M25LC320Select = 1; // Deselect Service
   PreviousAddress = Address; // Keep last address used
   WIPPolling(); // Wait for Write to Complete
}

/***********************************************************************/
/*                                                                     */
/*     Function: Block Write Memory (BlockWriteMem)                    */
/*        Input: The Address of where to start writing.                */
/*               A pointer to the block of data which is to be written */
/*               in to memory                                          */
/*               The size of the block of data which is to be written  */
/*       Output: Success or failure. Since this is not really a        */
/*               communications device True is currently returned.     */
/*                                                                     */
/*     Overview: This is a binary block writing routeen.               */
/*                                                                     */
/***********************************************************************/
static Boolean BlockWriteMem(unsigned Address, byte *DataPtr, byte Length)
{
   M25LC320Select = 0; // Select Service
   SpiIO->Write(WRITE);
   SpiIO->Write(XBty(Address >> 8));
   SpiIO->Write(XBty(Address));
   SpiIO->BlockWrite(DataPtr, Length);
   M25LC320Select = 1; // Deselect Service
   PreviousAddress = Address; // Keep last address used
   WIPPolling(); // Wait for Write to Complete
   return True;
}

/***********************************************************************/
/*                                                                     */
/*     Function: Byte Read Memory (ByteReadMem)                        */
/*        Input: The address in memory of where to read one byte of    */
/*               data from.                                            */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: Read one byte of data from memory located at Address  */
/*                                                                     */
/***********************************************************************/
static int ByteReadMem(unsigned Address)
{
   int Results = 0;

   M25LC320Select = 0; // Select Service
   SpiIO->Write(READ);
   SpiIO->Write(XBty(Address >> 8));
   SpiIO->Write(XBty(Address));
   Results = (int)SpiIO->Read();
   M25LC320Select = 1; // Deselect Service
   return Results;
}

/***********************************************************************/
/*                                                                     */
/*     Function: Block Read Memory (BlockReadMem)                      */
/*        Input: The Address of where to start reading data.           */
/*               A pointer to the location for the data destination:   */
/*               Data read in from memory will go to where the pointer */
/*               location points.                                      */
/*               The size of the block of data which is to be read     */
/*       Output: Success or failure. Since this is not really a        */
/*               communications device True is currently returned.     */
/*                                                                     */
/*     Overview: This function reads in a block of data from memory    */
/*                                                                     */
/***********************************************************************/
static Boolean BlockReadMem(unsigned Address, byte *DataPtr, byte Length)
{
   M25LC320Select = 0; // Select Service
   SpiIO->Write(READ);
   SpiIO->Write(XBty(Address >> 8));
   SpiIO->Write(XBty(Address));
   SpiIO->BlockRead(DataPtr, Length);
   M25LC320Select = 1; // Deselect Service
   DELAY(50);
   PreviousAddress = Address; // Keep last address used
   return True;
}

/***********************************************************************/
/*                                                                     */
/*     Function: WIPPolling                                            */
/*        Input: None                                                  */
/*       Output: None                                                  */
/*                                                                     */
/*     Overview: This routine loops until WIP = 0                      */
/*                                                                     */
/***********************************************************************/
static void WIPPolling(void)
{
   EEPromStatus Status;
   do
   {
      DELAY(50);
      M25LC320Select = 0; //Select Service
      SpiIO->Write(RDSR); 
      Status.Stat = SpiIO->Read();
      M25LC320Select = 1; //Deselect Service
   }while (Status.WIP); //Check for WIP bit Set
}
